Main {
// log file parameters 
   log_file_name    = "test.log"
   log_all_nodes    = TRUE

// visualization dump parameters 
   viz_dump_interval     = 1          // zero to turn off
   viz_dump_dirname      = "test"
   visit_number_procs_per_file = 1    

// restart dump parameters 
   restart_interval        = 0        // zero to turn off
   restart_write_dirname   = "restart_test"

   max_num_time_steps = 200
}


Parflow {
     CartesianGeometry {
        domain_boxes  = [ (0,0,0) , (99,99,99) ]
	   x_lo          = 0, 0, 0         // lower end of computational domain.
           x_up          = 100, 100, 100   // upper end of computational domain.
     }

     regrid_timestep = 1

     StandardTagAndInitialize {
          tagging_method = "GRADIENT_DETECTOR"
     }

     LoadBalancer {
         // using default uniform load balance configuration
     }

     GriddingAlgorithm{
        max_levels = 1         // Maximum number of levels in hierarchy.

// Note: For the following regridding information, data is required for each
//       potential in the patch hierarchy; i.e., levels 0 thru max_levels-1.
//       If more data values than needed are given, only the number required
//       will be read in.  If fewer values are given, an error will result.
//
// Specify coarsening ratios for each level 1 through max_levels-1

   	   ratio_to_coarser {      // vector ratio to next coarser level
	   level_1 = 2 , 2, 2
     }

     largest_patch_size {
        level_0 = 40 , 40, 40
        // all finer levels will use same values as level_0...
     }

      smallest_patch_size {
      level_0 = 16 , 16, 16
      // all finer levels will use same values as level_0...
   }

   efficiency_tolerance    = 0.85e0   // min % of tag cells in new patch level
   combine_efficiency      = 0.95e0   // chop box if sum of volumes of smaller
                                      // boxes < efficiency * vol of large box
}

}


