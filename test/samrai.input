Main {
// log file parameters 
   log_file_name    = "test.log"
   log_all_nodes    = TRUE

// visualization dump parameters 
   viz_dump_interval     = 1          // zero to turn off
   viz_dump_dirname      = "test"
   visit_number_procs_per_file = 1    

// restart dump parameters 
   restart_interval        = 0        // zero to turn off
   restart_write_dirname   = "restart_test"

   max_num_time_steps = 200
}


Parflow {
     regrid_timestep = 1
     starting_lower_corner = 10, 50
     starting_size = 3, 3
     // Boat (still life)
     // starting_config = 1, 1, 0, 1, 0, 1, 0, 1, 0 
     // Blinker
     // starting_config = 0, 0, 0, 1, 1, 1, 0, 0, 0 
     // Glider
     starting_config = 0, 1, 0, 1, 0, 0, 1, 1, 1

     CartesianGeometry {
        domain_boxes  = [ (0,0) , (99,99) ]
	   x_lo          = 0, 0       // lower end of computational domain.
           x_up          = 100, 100   // upper end of computational domain.
           periodic_dimension = 1,1 // Periodic in both dimensions
     }

     StandardTagAndInitialize {
          tagging_method = "GRADIENT_DETECTOR"
     }

     LoadBalancer {
         // using default uniform load balance configuration
     }

     GriddingAlgorithm{
        max_levels = 1         // Maximum number of levels in hierarchy.

// Note: For the following regridding information, data is required for each
//       potential in the patch hierarchy; i.e., levels 0 thru max_levels-1.
//       If more data values than needed are given, only the number required
//       will be read in.  If fewer values are given, an error will result.
//
// Specify coarsening ratios for each level 1 through max_levels-1

   	   ratio_to_coarser {      // vector ratio to next coarser level
	   level_1 = 2 , 2
           level_2 = 2 , 2
           level_3 = 2 , 2
           level_4 = 2 , 2
     }

     largest_patch_size {
        level_0 = 40 , 40
        // all finer levels will use same values as level_0...
     }

      smallest_patch_size {
      level_0 = 16 , 16 
      // all finer levels will use same values as level_0...
   }

   efficiency_tolerance    = 0.85e0   // min % of tag cells in new patch level
   combine_efficiency      = 0.95e0   // chop box if sum of volumes of smaller
                                      // boxes < efficiency * vol of large box
}


}


